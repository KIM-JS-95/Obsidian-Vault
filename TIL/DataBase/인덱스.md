# [DataBase Index]

## 인덱스 정의

데이터베이스에서 "인덱스"는 특정 열 또는 속성에 대한 검색 속도를 향상시키기 위해 생성된 [자료구조](/TIL/ETC/자료구조.md)를 의미한다. 

데이터를 검색할때 발생되는 자원 소모는DB에 저장되어 있는 데이터량에 비례한다
 
자주 사용되는 'SEELCT * FROM <table>'의 경우 
제약조건의 없다면**Full Scannig Data**[^2] 방식으로 데이터를 조회하기 때문이다.

해당 문제를 해결하기 위해 MySQL에서는 `인덱스 테이블` 생성을 통한 검색 매커니즘을 제공한다.
 
> 인덱스[INDEX]:
> 데이터 검색시 발생하는 **불필요한 자원 소모를 회피** 하고 테이블의 검색 성능향상 자료구조 메커니즘

인덱스는 크게 `클러스터 인덱스`와 `보조 인덱스` 로구분할 수 있지만
좀더 세부적으로 Primary / Unique / Non-cluster 등이 있다.

### 클러스터 인덱스
`클러스터 인덱스`는 단일 테이블당 하나만 생성할 수 있는 특수한 인덱스이다.

클러스터 인덱스는 하나의 속성을 기준으로 `정렬(SORT)` 옵션이 포함되는 인덱스인데
이는 우리가 키를 생성하면 기본으로 지정해야하는 `PRIMARY KEY`와도 같다.  

** 때문에 MySql에서 PK가 지정된 테이블 생성과 동시에 클러스터 인덱스를 생성할 수 없다. **

### 클러스터 인덱스 생성

클러스터 인덱스의 특성을 살펴본다면 해당 속성에 <u>유일성을 가지며 NULL 값을 가져서는 안된다.</u>

요점을 본다면 `KEY` 를 통해 클러스터 인덱스를 설정하는 방법은 2 가지가 존재하게 된다.

> 1. PRIMARY KEY 
> 2. UNIQUE NOT NULL

```mysql

CREATE TABLE PK_Table (
    id INT [PRIMARY KEY | UNIQUE NOT NULL],
    이름 VARCHAR(50),
    나이 INT,
);

```

### 보조 인덱스
보조 인덱스는 클러스터와 달리 정렬의 특성이 없어 하나의 테이블에 ** 여러개** 를 생성할 수 있다.

```mysql
CREATE TABLE 예제테이블 (
    id INT PRIMARY KEY,
    이름 VARCHAR(50) [UNIQUE | UNIQUE NULL],
    나이 INT,
);

```

만일 한 테이블에 2 가지 방식이 모두 선언되어 있다면 
튜플의 정렬 우선순위는 `PRIMARY KEY`가 선언된 튜플이 우선순위가 된다.

```mysql
CREATE TABLE TEST_TABLE (
    id INT PRIMARY KEY,
    name VARCHAR UNIQUE NOT NULL
);
```

두 인덱스 모두 데이터의 검색 속도 향상을 목적으로 존재하는 메커니즘 이지만

클러스터 인덱스는 PK를 기준으로 정렬을 통한 빠른 검색을 목적으로 하며 
보조 인덱스는 사용자가 특정하는 키워드 검색을 목적으로 하고 있음을 인지하고 있어야한다.

## 동작

인덱스를 통해 데이터 검색이 빨라질수 있는 이유는 

DB에 설정되어 있는 데이터 크기[^1]만큼 데이터를 `페이징`으로 나누고 [B-Tree](/TIL/ETC/B-Tree)방식으로 
데이터를 검색하여 동작하기 때문이다.

클러스터 인덱스와 보조 인덱스 두 인덱스 모두 B-Tree 자료구조를 기반으로 검색을 진행하지만
두 인덱스가 데이터를 구성하는 페이지 구조에는 큰 차이가 있다

### 클러스터 인덱스
![](/TIL/images/클러스터인덱스.png)

100개의 데이터를 가진 테이블에서 인덱스를 구성할 경우 16Kbyte 단위로 리프 페이지가 구성될 것이며
단일 페이지의 가장 앞에있는 각 데이터가 루트 페이지로 구성될 것이다.

이때 데이터를 찾기위해 루트페이지 에서는 리프 페이지의 페이지 번호를 이용해 데이터를 범위로 검색하며 찾게된다.

### 보조 인덱스

![](/TIL/images/보조인덱스.png)

보조 인덱스는 인덱스 페이지(루트 페이지와 리프 페이지) 외에 추가로 모든 데이터가 저장되어 있는 데이터 페이지가 추가로 존재한다.

리프페이지에는 (페이지 번호와 오프셋)으로 구성된 데이터 포인터 값이 데이터 페이지의 주솟값으로 사용된다.

두 인덱스의 검색 속도를 비교한다면 범위검색에 유리한 `클러스터 인덱스`가 빠르다.

그러나 데이터 수정이 이루어지는(입력/수정/삭제)에서의 인덱스 처리속도는 
SORT가 이루어지지 않는 `보조 인덱스`가 빠른 작업을보인다.

반대로 말하면 정렬이 이루어지는 클러스터 인덱스는 비교적 느린 처리속도를 보인다.

### 장점과 단점
인덱스를 이용한 데이터 방색 방식이 항상 답은아니다.

사용자가 인덱스를 생성하는 목적은 분면히 검색속도의 향샹에 있지만
해당 테이블에 데이터의 입력/수정/삭제가 이루어진다면 인덱스의 종류에 따라 처리시간이 증가할 것이다.

또한 인덱스에 묶여있는 보조 인덱스의 수 그리고 데이터의 크기가 커질 수록 용량이 늘어날 것이다.[^4]

정리하면 `인덱스` 는 목적에 따라 테이블에 어떤 인덱스를 적용할지 고민하고 
적용한다면 중복도가 낮은 속성을 찾아 적용하는 것이 바람직하다.[^3]


# Annotation

[^1]: Mysql의 경우 단위 페이징의 크기는 16Kbyte이다.

[^2]: Mysql환경에서 데이터 검색시 스캔 데이터가  전체 데이터의 15%이상일 경유 시스템은 작동으로 'Full Scanning' 방식으로 변경된다.

[^3]: 인덱스 성능은 Cordinality가 높은수록(원소의 중복 데이터가 적을 수록) 좋다.

[^4]: 불필요한 인덱스는 삭제하여 용량을 확보하자


# 프록시

## 지연로딩

연관되어 있는 엔티티를 조회할 경우 불필요한 정보까지 모든 엔티티를 불러오는 것은 현명한 방법은 아니다.

JPA에서는 효율적인 데이터 호출을 위해 데이터 베이스 조회를 지연하는 `지연로딩` 방식을 제공한다.

## 프록시 등장 개념

지연로딩 기능을 사용하려면 실제 엔티티 객체 대신에 직접 연관 엔티티를 호출하기 전까지 
DB 조회를 지연할 수 있는 `가짜 객체 (프록시)`가 필요했다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fpk1WQ%2FbtqLcU9GCPS%2Fa2tuzoKPP2UJeCn6IxQfxK%2Fimg.png)

## 프록시 특징
- 최초 한번만 초기화 할 수 있다.
- 츠록시는 원본 엔티티를 상속받은 객체이다.
- 프록시 객체가 초기화 되면 실체 객체에 점근할 수 있는 권한이 생긴다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 DB를 조회할 필요가 없으므로 `em.getReference()`를 호출해도 프록시가 아닌 실체 엔티티를 반환한다.
- 초기화는 연속성 컨텍스트의 도움을 받아야 가능한다. **즉, 준영속 상태의 프록시를 초기화 할 수 없다.**

## 프록시와 식별자
엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.

식벌자 값을 가지고 있는 프록시 객체는 일반적으로 식별자 값을 조회하는 `예)team.getId()`를 호출해도 프록시를 초기화하지 않지만
**어노테이션 설정 방식에 따라 초기화 여부가 달라진다.**

- @Access
  - JPA가 엔티티 데이터에 접근하는 방식을 지정



- @Access(AccessType.PROPERTY)
  - Getter 방식으로 접근이 가능하다. 
  - 메소드를 초기화 하지 않는다.



- @Access(AccessType.FIELD)
  - 필드에 직접 접근하는 방식으로 `private` 여도 접근이 가능하다.
  - JPA는 해당 어노테이션을 설정한 메소드의 목적성을 알 수 없어 해당 메소드를 초기화 한다.

## 프록시와 컬렉션 래퍼

단일 엔티티를 지연로딩 하게 된다면 `프록시` 객체를 사용해서 지연로딩을 수행한다.

그러면 컬렉션을 적용한 엔티티의 경우 하이버네이트는 어떻게 관리할까?

**하이버네이트는 프록시에게 컬랙션 타입의 엔티티 객체를 제공한다.**

하이버네이트는 엔티티를 연속 상태로 만들 때 엔티팅레 컬렉션이 있으면 컬렉션을 추적하고 관리한 목적으로 원본 컬렉션을
하이버네이터가 제공하는 내장 컬렉션으로 변경하는데 이것을 `컬렉션 래퍼`라 한다.

컬렉션 래퍼는 `member.getOrder()` 방식의 호출로 초기화 되지 않으며 컬랙션 타입에 맞추어
`member.getOrder().get(0)`과 같은 방식으로 호출하여 데이터를 초기화 시킨다.

엔티티를 지연로딩하면 프록시 객체체를 사용해서 지연 로딩을 수행하지만,

List 와 같은 컬렉션 타입의 엔티티는 `컬렉션 래퍼`가 지연 로딩을 처리해 준다. 

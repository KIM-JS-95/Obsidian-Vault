---
layout: post 
title:  "객체지향설계의 5대 원칙 - ISP 편"
date:   2022-03-13 12:05:21 +0800 
tags: 면접 자바 SOLID
color: rgb(98,170,255)
subtitle: OOD 5대원칙
--- 

# 🚀 OOP를 올바르계 설계해 나가는 원칙
    
OOP의 4대 특성 `캡슐화`, `상속`, `추상화`, `다형성`은 객체지향 프로그래밍을 이어가는 동안 사용할 `Tool` 같은 역할이 된다.

도구가 있다면 용도에 맞게 사용해야하는데 요리를 하면 표준에 있듯이 OOP 세계에서도 원칙이라는 것이 존대한다.

`OOP`를 기반으로 설계하는 방식을 `OOD (Object Oriented Design)`이라고 하며 
설계 방법을 구체화 하여 정리한 원칙이 `SOLID`가 되는 것이다.

## 🌠  SOLID

원칙이 탄생한 것은 **높은 응집도와 낮은 결합도** 목표로 `로버트 C.마틴`이 확립한 개념이다.



### ☄ ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.

✔ SRP원칙 을 지킨 설계

![013](https://user-images.githubusercontent.com/65659478/158052290-41c3cd55-0edb-430f-b347-c1f3e86bc612.jpg)

이전 `SRP원칙` 에서 `남자` 클래스를 각 책임에 적합하도록 위와 같이 클래스를 분리하여 설계했다.

꼭 `남자` 클래스를 분리해야만 할까?

✔ ISP 원칙 을 지킨 설계

![014](https://user-images.githubusercontent.com/65659478/158052844-0f0e8786-ba4b-4302-b1ce-e34095739882.jpg)

클래스 분리가 어렵다면 역할을 부여할 수 있는 `인터페이스`를 구현하면 가능하다.

`ISP원칙`은 특별한 원칙이 아닌 `SRP원칙`과 비교한다면 **취향 차이** 라고 할 수 있다.

#### 인터페이스 최소주의 와 ISP원칙

`인터페이스`를 적용하는 원칙인 만큼 우리는 인터베이스의 규칙 **인터페이스 최소주의 원칙**을 따라야한다.
인터페이스를 공부했다면 **상위 클래스는 풍부할 수록 인터페이스는 작을 수록 좋다.** 라는 말을 보았을 것이다.

![015](https://user-images.githubusercontent.com/65659478/158052289-3c202de7-ce17-451f-b55e-ec18b52f40f1.jpg) 


A) 빈약한 상위 클래스(사람)의 경우 학생 클래스와 군인 클래스는 같은 속성인 
`생일` , `주민번호`와 `자다()`, `소개하다()`, `공부하다()` 메서드를 가지고 있다

✔ A의 설계를 따른 코딩

```java
import java.util.Date;

public class Driver {
	public static void main(String[] args) {
		사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
				"20190001");
		사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
				"19-12345678");

		System.out.println(김학생.이름);
		System.out.println(이군인.이름);

		// System.out.println(김학생.생일); // 사용불가
		// System.out.println(이군인.생일); // 사용불가

		System.out.println(((학생) 김학생).생일); // 캐스팅 필요
		System.out.println(((군인) 이군인).생일); // 캐스팅 필요

		// System.out.println(김학생.주민등록번호); // 사용불가
		// System.out.println(이군인.주민등록번호); // 사용불가

		System.out.println(((학생) 김학생).주민등록번호);
		// 캐스팅 필요
		System.out.println(((군인) 이군인).주민등록번호);
		// 캐스팅 필요

		김학생.먹다();
		이군인.먹다();

		// 김학생.자다(); // 사용불가
		// 이군인.자다(); // 사용불가

		((학생) 김학생).자다(); // 캐스팅 필요
		((군인) 이군인).자다(); // 캐스팅 필요

		// 김학생.소개하다(); // 사용불가
		// 이군인.소개하다(); // 사용불가

		((학생) 김학생).소개하다(); // 캐스팅 필요
		((군인) 이군인).소개하다(); // 캐스팅 필요

		((학생) 김학생).공부하다(); // 캐스팅 필요
		((군인) 이군인).훈련하다(); // 캐스팅 필요
	}
}
```

위의 경우 빈약한 상위 클래스의 문제로 하위 클래스에 접근하기 위해 `캐스팅`을 해야만 하는 상황이 일어난다.

즉, 상속이라는 이점을 볼 수 없는 것이다.

B) 는 공통 인스턴스와 메소드를 상위클래스로 보낸 것을 볼 수 있다.

```java
import java.util.Date;

public class Driver {
	public static void main(String[] args) {
		사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
				"20190001");
		사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
				"19-12345678");

		System.out.println(김학생.이름);
		System.out.println(이군인.이름);

		System.out.println(김학생.생일);
		System.out.println(이군인.생일);

		System.out.println(김학생.주민등록번호);
		System.out.println(이군인.주민등록번호);

		// System.out.println(김학생.학번); // 사용불가
		// System.out.println(이군인.군번); // 사용불가

		System.out.println(((학생) 김학생).학번);
		// 캐스팅 필요
		System.out.println(((군인) 이군인).군번);
		// 캐스팅 필요

		김학생.먹다();
		이군인.먹다();

		김학생.자다();
		이군인.자다();

		김학생.소개하다();
		이군인.소개하다();

		// 김학생.공부하다(); // 사용불가
		// 이군인.훈련하다(); // 사용불가

		((학생) 김학생).공부하다(); // 캐스팅 필요
		((군인) 이군인).훈련하다(); // 캐스팅 필요
	}
}
```

`캐스팅`을 줄이고 상속의 이점을 누리기 위해 공통 부분을 상위 클라스로 올린 것으로 `캐스팅` 사용을 줄였다.

정리하자면 `ISP원칙`은 **최소한의 기능만을 공개**하는 것을 목표로 설계하는 것이 좋다.


## 🧾 Reference
- [깃헙 - 스프링 입문 교재](https://github.com/expert0226/oopinspring)
- [책 - 스프링을 입문을 위한 자바 객체 지향의 원리와 이해](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=55641908)


